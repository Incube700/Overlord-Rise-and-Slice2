using UnityEngine;
using System.Collections;

/// <summary>
/// Система движения игрока для top-down 2D игры.
/// Обрабатывает ввод с клавиатуры, физическое движение через Rigidbody2D,
/// коллизии с окружающими объектами, и систему dash (уклонения).
/// </summary>
public class PlayerMovement : MonoBehaviour
{
    [Header("Настройки движения")]
    [SerializeField] private float moveSpeed = 5f; // Скорость движения игрока
    
    [Header("Настройки Dash")]
    [SerializeField] private float dashSpeed = 15f; // Скорость dash
    [SerializeField] private float dashDuration = 0.2f; // Длительность dash в секундах
    [SerializeField] private float dashCooldown = 1f; // Перезарядка dash в секундах
    [SerializeField] private bool dashMakesInvulnerable = true; // Неуязвимость во время dash
    
    [Header("Отладка")]
    [SerializeField] private bool enableDebugLogs = true; // Включить логгирование для отладки
    
    // Компоненты
    private Rigidbody2D rb2D;
    private Animator animator;
    
    // Переменные ввода
    private Vector2 movementInput;
    private Vector2 lastMovementDirection;
    
    // Состояние dash
    private bool isDashing = false;
    private bool canDash = true;
    private Vector2 dashDirection;
    
    // Состояние неуязвимости
    private bool isInvulnerable = false;
    
    // События для других систем
    public System.Action<bool> OnDashStateChanged; // Уведомление о смене состояния dash
    public System.Action<bool> OnInvulnerabilityChanged; // Уведомление о смене неуязвимости
    
    void Start()
    {
        InitializeComponents();
        ConfigureRigidbody();
    }
    
    void Update()
    {
        HandleInput();
        HandleDashInput();
    }
    
    void FixedUpdate()
    {
        if (!isDashing)
        {
            HandleMovement();
        }
    }
    
    /// <summary>
    /// Инициализирует необходимые компоненты
    /// </summary>
    private void InitializeComponents()
    {
        rb2D = GetComponent<Rigidbody2D>();
        animator = GetComponent<Animator>();
        
        if (rb2D == null)
        {
            Debug.LogError($"PlayerMovement: На объекте {gameObject.name} отсутствует компонент Rigidbody2D!");
        }
        
        if (animator == null && enableDebugLogs)
        {
            Debug.LogWarning($"PlayerMovement: На объекте {gameObject.name} отсутствует компонент Animator. Анимации dash не будут работать.");
        }
        
        if (enableDebugLogs)
        {
            Debug.Log($"PlayerMovement: Компоненты инициализированы для {gameObject.name}");
        }
    }
    
    /// <summary>
    /// Настраивает Rigidbody2D для top-down движения
    /// </summary>
    private void ConfigureRigidbody()
    {
        if (rb2D == null) return;
        
        // Отключаем гравитацию для top-down вида
        rb2D.gravityScale = 0f;
        
        // Замораживаем вращение, чтобы игрок не поворачивался при столкновениях
        rb2D.freezeRotation = true;
        
        if (enableDebugLogs)
        {
            Debug.Log("PlayerMovement: Rigidbody2D настроен для top-down движения");
        }
    }
    
    /// <summary>
    /// Обрабатывает ввод с клавиатуры для движения
    /// </summary>
    private void HandleInput()
    {
        // Во время dash не обрабатываем обычное движение
        if (isDashing) return;
        
        // Получаем ввод по горизонтали и вертикали (WASD или стрелки)
        float horizontalInput = Input.GetAxisRaw("Horizontal");
        float verticalInput = Input.GetAxisRaw("Vertical");
        
        // Сохраняем текущий ввод
        movementInput = new Vector2(horizontalInput, verticalInput);
        
        // Сохраняем направление движения для других систем
        if (movementInput.magnitude > 0.1f)
        {
            lastMovementDirection = movementInput.normalized;
        }
        
        // Обновляем аниматор
        UpdateAnimator();
    }
    
    /// <summary>
    /// Обрабатывает ввод для dash (Left Shift)
    /// </summary>
    private void HandleDashInput()
    {
        // Проверяем нажатие Left Shift для dash
        if (Input.GetKeyDown(KeyCode.LeftShift) && canDash && !isDashing)
        {
            // Определяем направление dash
            Vector2 dashDir = movementInput.magnitude > 0.1f ? movementInput.normalized : lastMovementDirection;
            
            if (dashDir.magnitude > 0.1f) // Есть направление для dash
            {
                StartDash(dashDir);
            }
            else if (enableDebugLogs)
            {
                Debug.Log("PlayerMovement: Нет направления для dash");
            }
        }
    }
    
    /// <summary>
    /// Запускает dash в указанном направлении
    /// </summary>
    private void StartDash(Vector2 direction)
    {
        if (isDashing || !canDash) return;
        
        dashDirection = direction.normalized;
        isDashing = true;
        canDash = false;
        
        // Устанавливаем неуязвимость если включена
        if (dashMakesInvulnerable)
        {
            SetInvulnerability(true);
        }
        
        // Уведомляем другие системы
        OnDashStateChanged?.Invoke(true);
        
        // Обновляем аниматор
        if (animator != null)
        {
            animator.SetBool("isDashing", true);
        }
        
        // Запускаем корутину dash
        StartCoroutine(DashRoutine());
        
        if (enableDebugLogs)
        {
            Debug.Log($"PlayerMovement: Начат dash в направлении {dashDirection}");
        }
    }
    
    /// <summary>
    /// Корутина выполнения dash
    /// </summary>
    private IEnumerator DashRoutine()
    {
        float elapsedTime = 0f;
        
        while (elapsedTime < dashDuration)
        {
            // Применяем скорость dash
            if (rb2D != null)
            {
                rb2D.linearVelocity = dashDirection * dashSpeed;
            }
            
            elapsedTime += Time.deltaTime;
            yield return null;
        }
        
        // Завершаем dash
        EndDash();
        
        // Запускаем корутину перезарядки
        StartCoroutine(DashCooldownRoutine());
    }
    
    /// <summary>
    /// Завершает dash
    /// </summary>
    private void EndDash()
    {
        isDashing = false;
        
        // Останавливаем игрока
        if (rb2D != null)
        {
            rb2D.linearVelocity = Vector2.zero;
        }
        
        // Убираем неуязвимость
        if (dashMakesInvulnerable)
        {
            SetInvulnerability(false);
        }
        
        // Уведомляем другие системы
        OnDashStateChanged?.Invoke(false);
        
        // Обновляем аниматор
        if (animator != null)
        {
            animator.SetBool("isDashing", false);
        }
        
        if (enableDebugLogs)
        {
            Debug.Log("PlayerMovement: Dash завершён");
        }
    }
    
    /// <summary>
    /// Корутина перезарядки dash
    /// </summary>
    private IEnumerator DashCooldownRoutine()
    {
        yield return new WaitForSeconds(dashCooldown);
        
        canDash = true;
        
        if (enableDebugLogs)
        {
            Debug.Log("PlayerMovement: Dash готов к использованию");
        }
    }
    
    /// <summary>
    /// Устанавливает состояние неуязвимости
    /// </summary>
    private void SetInvulnerability(bool invulnerable)
    {
        if (isInvulnerable == invulnerable) return;
        
        isInvulnerable = invulnerable;
        OnInvulnerabilityChanged?.Invoke(isInvulnerable);
        
        if (enableDebugLogs)
        {
            Debug.Log($"PlayerMovement: Неуязвимость {(isInvulnerable ? "включена" : "выключена")}");
        }
    }
    
    /// <summary>
    /// Обновляет параметры аниматора
    /// </summary>
    private void UpdateAnimator()
    {
        if (animator == null) return;
        
        // Обновляем параметры движения
        animator.SetBool("isMoving", IsMoving());
        animator.SetFloat("moveX", movementInput.x);
        animator.SetFloat("moveY", movementInput.y);
        animator.SetFloat("lastMoveX", lastMovementDirection.x);
        animator.SetFloat("lastMoveY", lastMovementDirection.y);
    }
    
    /// <summary>
    /// Обрабатывает физическое движение игрока
    /// </summary>
    private void HandleMovement()
    {
        if (rb2D == null || isDashing) return;
        
        // Создаем вектор движения
        Vector2 movement = movementInput;
        
        // Нормализуем диагональное движение, чтобы скорость была одинаковой во всех направлениях
        if (movement.magnitude > 1f)
        {
            movement = movement.normalized;
        }
        
        // Применяем скорость движения
        movement *= moveSpeed;
        
        // Устанавливаем скорость Rigidbody2D
        rb2D.linearVelocity = movement;
    }
    
    /// <summary>
    /// Обрабатывает столкновения с другими объектами
    /// </summary>
    void OnCollisionEnter2D(Collision2D collision)
    {
        if (enableDebugLogs)
        {
            Debug.Log($"PlayerMovement: Столкновение с объектом '{collision.gameObject.name}' (тег: '{collision.gameObject.tag}')");
        }
        
        // Специальная обработка столкновений со стенами
        if (collision.gameObject.CompareTag("Wall"))
        {
            HandleWallCollision(collision);
        }
    }
    
    /// <summary>
    /// Обрабатывает начало триггерных столкновений
    /// </summary>
    void OnTriggerEnter2D(Collider2D other)
    {
        if (enableDebugLogs)
        {
            Debug.Log($"PlayerMovement: Вход в триггер '{other.gameObject.name}' (тег: '{other.gameObject.tag}')");
        }
        
        // Здесь можно добавить обработку триггеров (например, сбор предметов, переходы между уровнями)
    }
    
    /// <summary>
    /// Специальная обработка столкновений со стенами
    /// </summary>
    private void HandleWallCollision(Collision2D collision)
    {
        if (enableDebugLogs)
        {
            Vector2 contactPoint = collision.contacts[0].point;
            Vector2 contactNormal = collision.contacts[0].normal;
            
            Debug.Log($"PlayerMovement: Столкновение со стеной в точке {contactPoint}, нормаль: {contactNormal}");
        }
        
        // Во время dash прерываем его при столкновении со стеной
        if (isDashing)
        {
            StopCoroutine(DashRoutine());
            EndDash();
            StartCoroutine(DashCooldownRoutine());
            
            if (enableDebugLogs)
            {
                Debug.Log("PlayerMovement: Dash прерван столкновением со стеной");
            }
        }
        
        // Здесь можно добавить специальную логику для стен:
        // - Звуковые эффекты
        // - Частицы
        // - Проверка на возможность разрушения стены
    }
    
    #region Публичные методы для других систем
    
    /// <summary>
    /// Возвращает текущее направление движения (нормализованное)
    /// </summary>
    public Vector2 GetMovementDirection()
    {
        return movementInput.magnitude > 0.1f ? movementInput.normalized : Vector2.zero;
    }
    
    /// <summary>
    /// Возвращает последнее направление движения (для анимаций когда игрок стоит)
    /// </summary>
    public Vector2 GetLastMovementDirection()
    {
        return lastMovementDirection;
    }
    
    /// <summary>
    /// Проверяет, движется ли игрок в данный момент
    /// </summary>
    public bool IsMoving()
    {
        return movementInput.magnitude > 0.1f && !isDashing;
    }
    
    /// <summary>
    /// Проверяет, выполняет ли игрок dash в данный момент
    /// </summary>
    public bool IsDashing()
    {
        return isDashing;
    }
    
    /// <summary>
    /// Проверяет, может ли игрок использовать dash
    /// </summary>
    public bool CanDash()
    {
        return canDash && !isDashing;
    }
    
    /// <summary>
    /// Проверяет, неуязвим ли игрок в данный момент
    /// </summary>
    public bool IsInvulnerable()
    {
        return isInvulnerable;
    }
    
    /// <summary>
    /// Получает текущую скорость игрока
    /// </summary>
    public float GetCurrentSpeed()
    {
        return rb2D != null ? rb2D.linearVelocity.magnitude : 0f;
    }
    
    /// <summary>
    /// Устанавливает новую скорость движения (для временных эффектов)
    /// </summary>
    public void SetMoveSpeed(float newSpeed)
    {
        moveSpeed = newSpeed;
        
        if (enableDebugLogs)
        {
            Debug.Log($"PlayerMovement: Скорость движения изменена на {newSpeed}");
        }
    }
    
    /// <summary>
    /// Принудительно запускает dash в указанном направлении (для других систем)
    /// </summary>
    public void ForceDash(Vector2 direction)
    {
        if (direction.magnitude > 0.1f)
        {
            StartDash(direction);
        }
    }
    
    /// <summary>
    /// Останавливает игрока (например, для кат-сцен или паузы)
    /// </summary>
    public void StopMovement()
    {
        if (rb2D != null)
        {
            rb2D.linearVelocity = Vector2.zero;
        }
        
        movementInput = Vector2.zero;
        
        // Прерываем dash если он активен
        if (isDashing)
        {
            StopAllCoroutines();
            EndDash();
            canDash = true; // Сбрасываем кулдаун при принудительной остановке
        }
    }
    
    #endregion
} 